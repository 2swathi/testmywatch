/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   jam_resource.c
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 *   Use APIs in this file to manage the reource opened by Java.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

 #if 1
#include "jam_internal.h"
#include "j2me_custom_option.h"
#include "jma_internal.h"

#ifndef __MTK_TARGET__
#define MYASSERT(x) if(!x) ((int*)0)[0] = 0;
#else 
#define MYASSERT ASSERT
#endif 

resource_mgr_array_struct *resource_array;
static resource_mgr_struct *findOutEmptyEntry(void);
static kal_bool isResourceRegistered(int device_type, int handle);
int resouceDeregWoCS(int device_type, int handle);

/*
 * flag to mark audio device force switched and resumed in MMI context.
 * * VM should check these flags to decide execute device's pause/resume 
 * * handler or not.
 */
static kal_bool j2me_resource_suspended = KAL_FALSE;


/*****************************************************************************
 * FUNCTION
 *  initializeResoueceMgr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
int initializeResoueceMgr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    j2me_resource_suspended = KAL_FALSE;
    resource_array = (resource_mgr_array_struct*) jvm_malloc(sizeof(resource_mgr_array_struct));
    if (resource_array == NULL)
    {
        return RESOUCE_FAIL;
    }
    kal_mem_set(resource_array, 0, sizeof(resource_mgr_array_struct)); // 20090409: Changed

    RES_CS_ENTER();
    for (i = 0; i < RESOUCE_ARRAY_SIZE; i++)
    {
        resource_array->resouce[i].device_type = JAVA_INVALID_DEVICE;
    }
    resource_array->next = NULL;
    resource_array->next_free_index = 0;
    RES_CS_LEAVE();

    return RESOUCE_NO_ERROR;
}


/*****************************************************************************
 * FUNCTION
 *  finalizeResoueceMgr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void finalizeResoueceMgr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    resource_mgr_array_struct *temp_array = resource_array;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RES_CS_ENTER();

    while (temp_array != NULL)
    {
        int i;
        resource_mgr_array_struct *temp_save = temp_array;

        for (i = 0; i < RESOUCE_ARRAY_SIZE; i++)
        {
            if (temp_array->resouce[i].close != NULL)
            {
                if (temp_array->resouce[i].close(temp_array->resouce[i].handle) != RESOUCE_NO_ERROR)
                    /* Reset close handler */
                {
                    temp_array->resouce[i].close = NULL;
                }
            }
        }
        temp_array = temp_array->next;
        /* memory leak */
        jvm_free(temp_save);
    }

    resource_array = NULL;
    
    RES_CS_LEAVE();
}

/*****************************************************************************
 * FUNCTION
 *  finalize_net_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void finalize_net_res(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    resource_mgr_array_struct *temp_array = resource_array;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RES_CS_ENTER();
    while (temp_array != NULL)
    {
        int i;
        for (i = 0; i < RESOUCE_ARRAY_SIZE; i++)
        {
            if (temp_array->resouce[i].close != NULL &&
                 (temp_array->resouce[i].device_type == JAVA_IO_SOCKET_DEVICE ||
                  temp_array->resouce[i].device_type == JAVA_IO_DATAGRAM_DEVICE))
            {
                if (temp_array->resouce[i].close(temp_array->resouce[i].handle) != RESOUCE_NO_ERROR)
                    /* Reset close handler */
                {
                    temp_array->resouce[i].close = NULL;
                }
                temp_array->resouce[i].device_type = JAVA_INVALID_DEVICE;
                temp_array->resouce[i].handle = 0;
            }
        }
        temp_array = temp_array->next;
      }

    RES_CS_LEAVE();
}

/*****************************************************************************
 * FUNCTION
 *  resouceRegistering
 * DESCRIPTION
 *  
 * PARAMETERS
 *  device_type     [IN]        
 *  handle          [IN]        
 *  suspend         [IN]        
 *  resume          [IN]        
 *  close           [IN]        
 * RETURNS
 *  
 *****************************************************************************/
int resouceRegistering(
        int device_type,
        int handle,
        int (*suspend) (int handle),
        int (*resume) (int handle),
        int (*close) (int handle))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    resource_mgr_struct *resouce = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/       
    if(resource_array == NULL)
	{
		return RESOUCE_FAIL;
	}

    if (isResourceRegistered(device_type, handle) == KAL_TRUE)
    {
        return RESOUCE_EXISTED;
    }

    RES_CS_ENTER();
    resouce = findOutEmptyEntry();

    if (resouce != NULL)
    {
        resouce->device_type = device_type;
        resouce->handle = handle;
        resouce->suspend = suspend;
        resouce->resume = resume;
        resouce->close = close;
    }
    else
    {
        MYASSERT(0);
    }
    RES_CS_LEAVE();

    return RESOUCE_NO_ERROR;
}


/*****************************************************************************
 * FUNCTION
 *  isResourceRegistered
 * DESCRIPTION
 *  
 * PARAMETERS
 *  device_type     [IN]        
 *  handle          [IN]        
 * RETURNS
 *  
 *****************************************************************************/
static kal_bool isResourceRegistered(int device_type, int handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    resource_mgr_array_struct *temp_array = resource_array;
    int i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while (temp_array != NULL)
    {
        for (i = 0; i < RESOUCE_ARRAY_SIZE; i++)
        {
            if ((temp_array->resouce[i].device_type == device_type) && (temp_array->resouce[i].handle == handle))
            {
                return KAL_TRUE;
            }
        }
        temp_array = temp_array->next;
    }
    return KAL_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  findOutEmptyEntry
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static resource_mgr_struct *findOutEmptyEntry(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    resource_mgr_array_struct *temp_array = resource_array;
    resource_mgr_array_struct *temp_save = NULL;
    int i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while (temp_array != NULL)
    {
        temp_save = temp_array;

        if (temp_array->next_free_index == -1)
        {
            temp_array = temp_array->next;
        }
        else
        {
            resource_mgr_struct *empty_entry = &temp_array->resouce[temp_array->next_free_index];

            for (i = 0; i < RESOUCE_ARRAY_SIZE; i++)
            {
                if ((temp_array->resouce[i].device_type == JAVA_INVALID_DEVICE) && (i != temp_array->next_free_index))
                {
                    temp_array->next_free_index = i;
                    break;
                }
            }

            if (i == RESOUCE_ARRAY_SIZE)
            {
                temp_array->next_free_index = -1;
            }

            return empty_entry;
        }
    }

    /* Expand array */
    temp_array = (resource_mgr_array_struct*) jvm_malloc(sizeof(resource_mgr_array_struct));
    if (temp_array == NULL)
    {
        return NULL;
    }

    kal_mem_set(temp_array, 0, sizeof(resource_mgr_array_struct)); // 20090409: Changed
    for (i = 0; i < RESOUCE_ARRAY_SIZE; i++)
    {
        temp_array->resouce[i].device_type = JAVA_INVALID_DEVICE;
    }

    temp_array->next = NULL;
    temp_array->next_free_index = 1;
    temp_save->next = temp_array;

    return &temp_array->resouce[0];
}


/*****************************************************************************
 * FUNCTION
 *  resouceDereg
 * DESCRIPTION
 *  
 * PARAMETERS
 *  device_type     [IN]        
 *  handle          [IN]        
 * RETURNS
 *  
 *****************************************************************************/
int resouceDereg(int device_type, int handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RES_CS_ENTER();
    result = resouceDeregWoCS(device_type, handle);
    RES_CS_LEAVE();
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  resouceDeregWoCS
 * DESCRIPTION
 *  
 * PARAMETERS
 *  device_type     [IN]        
 *  handle          [IN]        
 * RETURNS
 *  
 *****************************************************************************/
int resouceDeregWoCS(int device_type, int handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    resource_mgr_array_struct *temp_array = resource_array;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while (temp_array != NULL)
    {
        int i;

        for (i = 0; i < RESOUCE_ARRAY_SIZE; i++)
        {
            if ((temp_array->resouce[i].device_type == device_type) && (temp_array->resouce[i].handle == handle))
            {
                temp_array->resouce[i].device_type = JAVA_INVALID_DEVICE;
                temp_array->resouce[i].handle = 0;
                temp_array->resouce[i].close = NULL;
                temp_array->resouce[i].resume = NULL;
                temp_array->resouce[i].suspend = NULL;
                if (i < temp_array->next_free_index)
                {
                    temp_array->next_free_index = i;
                }
                return RESOUCE_NO_ERROR;
            }
        }
        temp_array = temp_array->next;
    }

    return RESOUCE_NOT_FOUND;
}


/*****************************************************************************
 * FUNCTION
 *  resouceCloseAndDereg
 * DESCRIPTION
 *  
 * PARAMETERS
 *  device_type     [IN]        
 *  handle          [IN]        
 * RETURNS
 *  
 *****************************************************************************/
int resouceCloseAndDereg(int device_type, int handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    resource_mgr_array_struct *temp_array = resource_array;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while (temp_array != NULL)
    {
        int i;

        for (i = 0; i < RESOUCE_ARRAY_SIZE; i++)
        {
            if ((temp_array->resouce[i].device_type == device_type) && (temp_array->resouce[i].handle == handle))
            {
                int (*closeFun) (int handle) = temp_array->resouce[i].close;
                int closeHandle = temp_array->resouce[i].handle;

                temp_array->resouce[i].device_type = JAVA_INVALID_DEVICE;
                temp_array->resouce[i].handle = 0;
                temp_array->resouce[i].close = NULL;
                temp_array->resouce[i].resume = NULL;
                temp_array->resouce[i].suspend = NULL;
                if (i < temp_array->next_free_index)
                {
                    temp_array->next_free_index = i;
                }
                return closeFun(closeHandle);
            }
        }
        temp_array = temp_array->next;
    }
    return RESOUCE_NOT_FOUND;
}


/*****************************************************************************
 * FUNCTION
 *  resumeAll
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool is_resource_suspended(void)
{
    return j2me_resource_suspended;
}

#endif // if 0
